
#
# Script to infer ancestral corm states for Isoetes. States coded as:
#       0 = trilobate
#       1 = bilobate
#
# We use reversible-jump MCMC and a Dirichlet mixture model to explore the 
# space of all possible continuous-time Markov models of phenotypic 
# character evolution.
#
# We also optionally account for phylogenetic uncertainty by integrating 
# over a distribution of trees previously inferred using MrBayes.
#
# author: Will Freyman
#
#

# some settings for our analysis
analysis_name = "rj_dpp_model"
fixed_tree = false
mcmc_gen = 20000
burnin_gen = 2000
log_freq = 10
seed(1234)
mvi = 0
mni = 0

if (fixed_tree) {
    
    # read in the tree
    tree <- readTrees("data/MAP-rooted.tre")[1]

} else {

    # read in the distribution of trees
    trees = readBranchLengthTrees("data/rooted_trees.nexus")
    tree_trace = treeTrace(branch_length_trees=trees)

    # set up an empirical tree distribution with an MCMC move
    tree ~ dnEmpiricalTree(burnin=0, tree_trace)
    moves[++mvi] = mvEmpiricalTree( tree, weight=2 )

    # we'll also read in a pre-cooked MAP tree to summarize ancestral state on
    map_tree <- readTrees("data/MAP-rooted.tre")[1]

}

# read in corm data
data <- readCharacterDataDelimited("data/corm_data.csv", type="NaturalNumbers", stateLabels=2, delimiter=",", headers=false)

# A reversible-jump MCMC model of character evolution:
# here we assume that each transistion rate can be drawn
# from a mixture distribution, where each rate has an 
# equal prior probability of being 0.0 or of being drawn
# from one of two independent rates (r1 and r2). These 
# rates are each drawn from an exponential distribution
# with a mean of 10 character state transitions over 
# the tree. The MCMC will sample from irreversible, 
# 1-rate, and 2-rate models proportionately to their 
# posterior probability.
if (fixed_tree) {
    rate_pr := tree.treeLength() / 10
} else {
    rate_pr := map_tree.treeLength() / 10
}

alpha <- 1.0
base_rates ~ dnDPP( baseDistribution=dnExp(rate_pr), concentration=alpha, numElements=2 )
moves[++mvi] = mvDPPValueScaling( base_rates, weight=6 )
moves[++mvi] = mvDPPAllocateAuxGibbs( base_rates, numAux=4, weight=2 )

rate_01 ~ dnMixture([0.0, base_rates[1]], simplex(1, 1))
rate_10 ~ dnMixture([0.0, base_rates[2]], simplex(1, 1))

moves[++mvi] = mvMixtureAllocation( rate_01, weight=2 )
moves[++mvi] = mvMixtureAllocation( rate_10, weight=2 )

# here we set up the rate matrix Q
Q := fnFreeK( [ rate_01, rate_10 ], rescaled=false )

# set up the root state frequencies 
rf_prior <- [1,1]
rf ~ dnDirichlet( rf_prior )
moves[++mvi] = mvBetaSimplex( rf, weight=2 )
moves[++mvi] = mvDirichletSimplex( rf, weight=2 )

# set up the CTMC 
ctmc ~ dnPhyloCTMC( tree, Q, branchRates=1.0, rootFrequencies=rf, type="NaturalNumbers")
ctmc.clamp( data )


# set up the MCMC monitors
monitors[++mni] = mnModel(filename="output/" + analysis_name + ".log", printgen=log_freq)
monitors[++mni] = mnScreen(printgen=log_freq, rate_01, rate_10)
monitors[++mni] = mnJointConditionalAncestralState(tree=tree, ctmc=ctmc, type="NaturalNumbers", printgen=log_freq, withTips=true, withStartStates=false, filename="output/" + analysis_name + "-anc.log")
if (fixed_tree == false) {
    # we must keep tree samples that correspond with each ancestral state sample
    monitors[++mni] = mnFile(filename="output/" + analysis_name + ".trees", printgen=log_freq, tree)
}

# finalize the model 
mymodel = model(Q)


# run the MCMC simulation 
mymcmc = mcmc(mymodel, monitors, moves)
mymcmc.burnin(generations=burnin_gen,tuningInterval=log_freq)
mymcmc.run(generations=mcmc_gen)


# summarize ancestral states 

# first read in the sampled ancestral states
anc_states = readAncestralStateTrace("output/" + analysis_name + "-anc.log")
if (fixed_tree) {

    # annotate the tree with the MAP ancestral states
    anc_tree = ancestralStateTree(tree=tree, ancestral_state_trace_vector=anc_states, include_start_states=false, file="output/ancestral_states_" + analysis_name + ".tree", burnin=0, summary_statistic="MAP", site=0)

} else {

    # read in the tree samples that correspond with each ancestral state sample
    anc_trees = readAncestralStateTreeTrace("output/" + analysis_name + ".trees", treetype="non-clock")
    # annotate the MAP tree with the MAP ancestral states
    anc_tree = ancestralStateTree(tree=map_tree, ancestral_state_trace_vector=anc_states, tree_trace=anc_trees, include_start_states=false, file="output/ancestral_states_" + analysis_name + ".tree", burnin=0, summary_statistic="MAP", site=0)

}

q()
